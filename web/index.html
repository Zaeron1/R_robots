<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>Ricochet Robots (Web)</title>
  <style>
    :root {
      --bg: #121218;
      --panel: #1b1b24;
      --text: #e8e8f0;
      --accent: #6fa3ff;
    }
    body {
      margin: 0;
      background: radial-gradient(circle at 20% 20%, #171722, #0f0f17 60%);
      color: var(--text);
      font-family: "Inter", system-ui, -apple-system, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
      padding: 14px;
    }
    header {
      text-align: center;
    }
    #canvas-wrap {
      position: relative;
      box-shadow: 0 10px 50px rgba(0,0,0,0.45);
      border-radius: 14px;
      overflow: hidden;
    }
    #game {
      display: block;
      background: var(--bg);
    }
    #overlay {
      position: absolute;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(4px);
      background: rgba(0,0,0,0.35);
      color: #f5f5ff;
      font-size: 22px;
      font-weight: 700;
      text-align: center;
      padding: 24px;
    }
    #panel {
      background: var(--panel);
      padding: 10px 14px;
      border-radius: 10px;
      display: flex;
      gap: 16px;
      flex-wrap: wrap;
      align-items: center;
      justify-content: center;
      box-shadow: 0 4px 16px rgba(0,0,0,0.35);
    }
    button {
      background: #252533;
      color: var(--text);
      border: 1px solid #414155;
      padding: 8px 14px;
      border-radius: 9px;
      cursor: pointer;
    }
    button:hover { border-color: var(--accent); }
    .pill { padding: 6px 10px; background: #1f1f2a; border-radius: 8px; }
    a { color: var(--accent); }
  </style>
</head>
<body>
  <header>
    <h1>Ricochet Robots - Version Web (démo locale)</h1>
    <p>Servez le dossier et ouvrez cette page pour jouer : <code>python3 -m http.server 8000</code> puis allez sur <code>http://localhost:8000/web/index.html</code>.</p>
  </header>

  <div id="panel">
    <span class="pill" id="status">Chargement…</span>
    <button id="btn-reload">Recharger le board</button>
    <button id="btn-newgame">Nouvelle partie</button>
    <span class="pill" id="moves">Coups : 0</span>
    <span class="pill" id="target">Cible : …</span>
  </div>

  <div id="canvas-wrap">
    <canvas id="game" width="900" height="820"></canvas>
    <div id="overlay"></div>
  </div>

  <script>
    // ---- UI helpers ----
    const TILE = 40;
    const MARGIN = 16;
    const TOPBAR = 80;
    const COLORS = {
      RED:   "#dc3c3c",
      BLUE:  "#468ce6",
      GREEN: "#44c07a",
      YELLOW:"#e0c14d",
      WHITE: "#e8e8f0"
    };
    const SYMBOL_DRAW = {
      CIRCLE: (ctx, cx, cy, s) => { ctx.beginPath(); ctx.arc(cx, cy, s, 0, Math.PI*2); ctx.fill(); },
      SQUARE: (ctx, cx, cy, s) => { ctx.fillRect(cx - s, cy - s, 2*s, 2*s); },
      DIAMOND:(ctx, cx, cy, s) => { ctx.beginPath(); ctx.moveTo(cx, cy - s); ctx.lineTo(cx + s, cy); ctx.lineTo(cx, cy + s); ctx.lineTo(cx - s, cy); ctx.closePath(); ctx.fill(); },
      TRI:    (ctx, cx, cy, s) => { ctx.beginPath(); ctx.moveTo(cx, cy - s); ctx.lineTo(cx + s, cy + s); ctx.lineTo(cx - s, cy + s); ctx.closePath(); ctx.fill(); },
    };
    const DIRS = [{x:0,y:-1},{x:1,y:0},{x:0,y:1},{x:-1,y:0}]; // U,R,D,L
    const DIR_MAP = {U:0,R:1,D:2,L:3};

    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    const overlay = document.getElementById("overlay");
    const statusEl = document.getElementById("status");
    const movesEl = document.getElementById("moves");
    const targetEl = document.getElementById("target");

    let board = null;
    let robots = [0,0,0,0,0]; // 5 robots (0..4, 4th = white)
    let selected = 0;
    let remainingTargets = [];
    let currentTarget = null;
    let anim = null;
    let moves = 0;

    async function loadBoard() {
      try {
        const res = await fetch("../boards/out/board_full.json");
        if (!res.ok) throw new Error(res.statusText);
        return await res.json();
      } catch (e) {
        console.warn("Board indisponible, utilisation d'un exemple embarqué.", e);
        return {
          grid_size: 16,
          blocked: [
            {x:7,y:7},{x:8,y:7},{x:7,y:8},{x:8,y:8}
          ],
          walls: [],
          targets: [
            {x:1,y:1,color:"RED",symbol:"CIRCLE"},
            {x:5,y:1,color:"BLUE",symbol:"DIAMOND"},
            {x:1,y:5,color:"GREEN",symbol:"TRI"},
            {x:6,y:6,color:"YELLOW",symbol:"SQUARE"}
          ],
          meta: {picks:{}}
        };
      }
    }

    function buildBoard(data) {
      const W = data.grid_size;
      const N = W*W;
      const walls = new Array(N).fill(0);
      const blocked = new Array(N).fill(false);
      const idxToXY = Array.from({length:N}, (_,i)=>({x:i%W,y:Math.floor(i/W)}));
      for (const b of data.blocked||[]) {
        const idx = b.y * W + b.x;
        blocked[idx] = true;
      }
      for (const w of data.walls||[]) {
        const idx = w.y * W + w.x;
        const bit = DIR_MAP[w.dir.toUpperCase()];
        if (bit !== undefined) walls[idx] |= (1 << bit);
      }
      return {
        W, H:W, N,
        walls,
        blocked,
        targets: (data.targets||[]).map(t=>({
          idx: t.y * W + t.x,
          color: t.color.toUpperCase(),
          symbol: t.symbol.toUpperCase()
        })),
        idxToXY,
      };
    }

    function randomRobotPositions(b) {
      const used = new Set();
      const res = [];
      for (let i=0;i<5;i++) {
        for (let k=0;k<5000;k++) {
          const idx = Math.floor(Math.random() * b.N);
          if (b.blocked[idx] || used.has(idx)) continue;
          used.add(idx);
          res.push(idx);
          break;
        }
      }
      return res;
    }

    function slide(b, state, robot, d) {
      let cur = state[robot];
      const {x,y} = b.idxToXY[cur];
      let cx=x, cy=y;
      const dx = DIRS[d].x, dy=DIRS[d].y;
      while (true) {
        const idx = cy * b.W + cx;
        if ((b.walls[idx] >> d) & 1) break;
        const nx = cx + dx, ny = cy + dy;
        if (nx<0 || ny<0 || nx>=b.W || ny>=b.H) break;
        const nidx = ny * b.W + nx;
        if (b.blocked[nidx]) break;
        if (state.some((p,ri)=>ri!==robot && p===nidx)) break;
        cx = nx; cy = ny;
      }
      return cy * b.W + cx;
    }

    function startAnim(robot, fromIdx, toIdx) {
      const startCell = cellRect(board, fromIdx).center;
      const endCell   = cellRect(board, toIdx).center;
      anim = {robot, start:startCell, end:endCell, t0:performance.now(), dur:180};
    }

    function cellRect(b, idx) {
      const {x,y} = b.idxToXY[idx];
      return {
        x: MARGIN + x * TILE,
        y: MARGIN + TOPBAR + y * TILE,
        w: TILE,
        h: TILE,
        center: [MARGIN + x * TILE + TILE/2, MARGIN + TOPBAR + y * TILE + TILE/2]
      };
    }

    function pickNextTarget() {
      if (!remainingTargets.length) {
        remainingTargets = [...board.targets];
        shuffle(remainingTargets);
      }
      currentTarget = remainingTargets.pop();
      targetEl.textContent = `Cible : ${currentTarget.color} / ${currentTarget.symbol}`;
    }

    function shuffle(arr) {
      for (let i=arr.length-1;i>0;i--) {
        const j = Math.floor(Math.random()*(i+1));
        [arr[i],arr[j]]=[arr[j],arr[i]];
      }
    }

    function draw() {
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = "#121218";
      ctx.fillRect(0,0,canvas.width,canvas.height);
      // grid
      for (let idx=0; idx<board.N; idx++) {
        if (board.blocked[idx]) continue;
        const {x,y} = board.idxToXY[idx];
        const rx = MARGIN + x*TILE;
        const ry = MARGIN + TOPBAR + y*TILE;
        ctx.fillStyle = "#1a1a22";
        ctx.fillRect(rx, ry, TILE, TILE);
        ctx.strokeStyle = "#2b2b38";
        ctx.strokeRect(rx, ry, TILE, TILE);
      }
      // center block
      for (let idx=0; idx<board.N; idx++) {
        if (!board.blocked[idx]) continue;
        const {x,y} = board.idxToXY[idx];
        const rx = MARGIN + x*TILE;
        const ry = MARGIN + TOPBAR + y*TILE;
        ctx.fillStyle = "#0d0d12";
        ctx.fillRect(rx, ry, TILE, TILE);
      }
      // targets
      for (const t of board.targets) {
        if (board.blocked[t.idx]) continue;
        const {x,y} = board.idxToXY[t.idx];
        const cx = MARGIN + x*TILE + TILE/2;
        const cy = MARGIN + TOPBAR + y*TILE + TILE/2;
        ctx.fillStyle = COLORS[t.color] || "#ccc";
        SYMBOL_DRAW[t.symbol]?.(ctx, cx, cy, TILE/2 - 10);
      }
      // walls
      ctx.strokeStyle = "#f3f3f5";
      ctx.lineWidth = 3;
      for (let idx=0; idx<board.N; idx++) {
        const {x,y} = board.idxToXY[idx];
        const mask = board.walls[idx];
        const rx = MARGIN + x*TILE;
        const ry = MARGIN + TOPBAR + y*TILE;
        if (mask & 1) { ctx.beginPath(); ctx.moveTo(rx, ry); ctx.lineTo(rx+TILE, ry); ctx.stroke(); }
        if (mask & 2) { ctx.beginPath(); ctx.moveTo(rx+TILE, ry); ctx.lineTo(rx+TILE, ry+TILE); ctx.stroke(); }
        if (mask & 4) { ctx.beginPath(); ctx.moveTo(rx, ry+TILE); ctx.lineTo(rx+TILE, ry+TILE); ctx.stroke(); }
        if (mask & 8) { ctx.beginPath(); ctx.moveTo(rx, ry); ctx.lineTo(rx, ry+TILE); ctx.stroke(); }
      }
      // robots
      const now = performance.now();
      for (let i=0;i<robots.length;i++) {
        const idx = robots[i];
        const rect = cellRect(board, idx);
        let cx = rect.center[0];
        let cy = rect.center[1];
        if (anim && anim.robot === i) {
          let t = (now - anim.t0)/anim.dur;
          if (t < 0) t = 0;
          if (t >= 1) t = 1;
          cx = anim.start[0] + (anim.end[0]-anim.start[0])*t;
          cy = anim.start[1] + (anim.end[1]-anim.start[1])*t;
          if (t >= 1) anim = null;
        }
        ctx.fillStyle = ["RED","BLUE","GREEN","YELLOW","WHITE"][i] ? COLORS[["RED","BLUE","GREEN","YELLOW","WHITE"][i]] : "#fff";
        ctx.beginPath();
        ctx.arc(cx, cy, TILE/2 - 6, 0, Math.PI*2);
        ctx.fill();
        if (i === selected) {
          ctx.strokeStyle = "#ffffff";
          ctx.lineWidth = 2;
          ctx.strokeRect(rect.x+4, rect.y+4, TILE-8, TILE-8);
        }
      }
      requestAnimationFrame(draw);
    }

    function cellFromPos(px, py) {
      px -= MARGIN;
      py -= MARGIN + TOPBAR;
      if (px < 0 || py < 0) return null;
      const x = Math.floor(px / TILE);
      const y = Math.floor(py / TILE);
      if (x < 0 || y < 0 || x >= board.W || y >= board.H) return null;
      return y * board.W + x;
    }

    function handleClick(ev) {
      if (!board || anim) return;
      const rect = canvas.getBoundingClientRect();
      const idx = cellFromPos(ev.clientX - rect.left, ev.clientY - rect.top);
      if (idx == null) return;
      const robotHere = robots.findIndex(r => r === idx);
      if (robotHere !== -1) {
        selected = robotHere;
        return;
      }
      if (board.blocked[idx]) return;
      const dir = lineDir(robots[selected], idx);
      if (dir == null) return;
      const stop = slide(board, robots, selected, dir);
      if (stop === robots[selected]) return;
      if (stop !== idx) return; // must be exact stop
      startAnim(selected, robots[selected], stop);
      robots[selected] = stop;
      moves += 1;
      movesEl.textContent = `Coups : ${moves}`;
      checkWin();
    }

    function lineDir(fromIdx, toIdx) {
      const fx = board.idxToXY[fromIdx].x;
      const fy = board.idxToXY[fromIdx].y;
      const tx = board.idxToXY[toIdx].x;
      const ty = board.idxToXY[toIdx].y;
      if (fx === tx) return ty > fy ? 2 : 0; // D or U
      if (fy === ty) return tx > fx ? 1 : 3; // R or L
      return null;
    }

    function checkWin() {
      if (!currentTarget) return;
      const colorIdx = {"RED":0,"BLUE":1,"GREEN":2,"YELLOW":3}[currentTarget.color];
      if (colorIdx == null) return;
      if (robots[colorIdx] === currentTarget.idx) {
        overlay.textContent = `Manche gagnée en ${moves} coups ! Cliquez pour continuer.`;
        overlay.style.display = "flex";
        overlay.onclick = () => {
          overlay.style.display = "none";
          pickNextTarget();
        };
      }
    }

    async function newGame() {
      statusEl.textContent = "Chargement…";
      const data = await loadBoard();
      board = buildBoard(data);
      robots = randomRobotPositions(board);
      selected = 0;
      remainingTargets = [...board.targets];
      shuffle(remainingTargets);
      pickNextTarget();
      moves = 0;
      movesEl.textContent = "Coups : 0";
      statusEl.textContent = "Prêt";
      overlay.style.display = "none";
    }

    canvas.addEventListener("click", handleClick);
    document.getElementById("btn-reload").onclick = newGame;
    document.getElementById("btn-newgame").onclick = newGame;

    newGame();
    requestAnimationFrame(draw);
  </script>
</body>
</html>
